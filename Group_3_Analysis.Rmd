---
title: "Group_3_Analysis"
author: "Group_3"
date: "2023-03-10"
output: html_document
---
# Aim of Analysis

# Exploratory Analysis

## Data Wrangling
```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#load library
library(dplyr)
library(tidyr)
library(skimr)
library(tidytext)
library(stringr)
```

```{r Binary output label}
imdb <- read.csv("https://raw.githubusercontent.com/fanghuaqiu/DMML-Group-3/main/group_3.csv",na.strings = "") %>%
  mutate(ROI = (gross-budget)/budget) %>% #define ROI
  mutate(scs = ifelse(ROI>=1,1,0)) %>% #define binary labelled output
  mutate(title_year = as.factor(title_year),
         aspect_ratio = as.factor((aspect_ratio)),
         scs = as.factor(scs),
         content_rating = replace_na(content_rating, "Unknown"),
         country = str_replace(country," ","_"),
         content_rating = str_replace(content_rating," ","_"))%>%
  mutate(content_rating = str_replace(content_rating,"-1","_1"))
```


```{r turn categorical variable to dummy variable}
#Turn genres into matrix
imdb_genre <- imdb[,c("movie_title","genres")] %>%
  mutate(has=1) %>%
  unnest_tokens(genres_c, genres, to_lower=F) %>%
  filter(genres_c != "Fi" & genres_c != "Film") %>%
  group_by(movie_title) %>%
  spread(genres_c,has,fill=0)

#turn categorical variable into dummy variables
dummies <- model.matrix(~color+language+country+title_year+aspect_ratio+content_rating,data=imdb)[,-1]

#Combine datasets, need to adjust for standised data
imdb_dummy <- cbind(imdb,dummies) %>%
    left_join(imdb_genre, by = "movie_title")

skim(imdb_dummy)
```


```{r Separate training, validation and test sets}
same_sample <- function(x,y){
  set.seed(84)
  return(sample(x,y))
}

index_test <- same_sample(1:nrow(imdb), round(0.25*nrow(imdb)))
index_val <- same_sample((1:nrow(imdb))[-index_test], round(0.25*nrow(imdb)))
index_train <- setdiff(1:nrow(imdb),c(index_test,index_val))

test_imdb <- imdb_dummy[index_test,]
valid_imdb <- imdb_dummy[index_val,]
train_imdb <- imdb_dummy[index_train,]
# training set for tree model
index_train_t <- same_sample(setdiff(1:nrow(imdb),c(index_test,index_val)), round(0.25*nrow(imdb)))

train_imdb_t <- imdb_dummy[index_train_t,]
```

```{r balanced sets}
same_sample <- function(x,y){
  set.seed(84)
  return(sample(x,y))
}

# balanced
index_train_1 <- same_sample(which(imdb$scs == '1'), round(0.25*nrow(imdb)))
index_train_0 <- same_sample(which(imdb$scs == '0'), round(0.25*nrow(imdb)))
index_train_b <- c(index_train_1,index_train_0)
index_val_b <- same_sample((1:nrow(imdb))[-index_train_b], round(0.25*nrow(imdb)))
index_test_b <- setdiff(1:nrow(imdb),c(index_val_b,index_train_b))

test_imdb_b <- imdb_dummy[index_test_b,]
valid_imdb_b <- imdb_dummy[index_val_b,]
train_imdb_b <- imdb_dummy[index_train_b,]

dim(test_imdb_b)
# training set for tree model
index_train_t_1 <- same_sample(which(train_imdb_b$scs == '1'), round(0.25*nrow(train_imdb_b)))
index_train_t_0 <- same_sample(which(train_imdb_b$scs == '0'), round(0.25*nrow(train_imdb_b)))
index_train_b_t <- c(index_train_t_1,index_train_t_0)

train_imdb_b_t <- train_imdb_b[index_train_b_t,]
```



# Modelling

## KNN

## LDA

## Tree

## SVM

##Neural Network

#Conclusion

